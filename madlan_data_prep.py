# -*- coding: utf-8 -*-
"""madlan_data_prep.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uSYdkkppOPHPRKLukhWPIDAlovLFOQw8

Finall task
 Ziv Kelmer and Noa Nesher
"""

import re
import numpy as np
import pandas as pd
import datetime
import string
# !pip install fuzzywuzzy
from fuzzywuzzy import fuzz
from fuzzywuzzy import process

"""**Data preparation**"""


def prepare_data(data):
    df = data.copy()
    df['price'] = df['price'].apply(lambda x: re.findall(r'\d+\.?\d*', str(x)))
    df['price'] = df['price'].apply(lambda x: ''.join(x) if len(x) > 0 else np.nan).astype(float)

    df['Area'] = df['Area'].apply(lambda x: re.findall(r'\d+\.?\d*', str(x)))
    df['Area'] = df['Area'].apply(lambda x: ''.join(x) if len(x) > 0 else np.nan).astype(float)

    df.dropna(subset=['price'], inplace=True)

    df['Street'] = df['Street'].str.replace('[,\\.]', '', regex=True)
    df['city_area'] = df['city_area'].str.replace('[,\\.]', '', regex=True)
    df['City'] = df['City'].str.replace('[,\\.]', '', regex=True)
    df['City'] = df['City'].str.replace('יי', 'י')
    df['description '] = df['description '].str.replace('[,\\.]', '', regex=True)
    df['description '] = df['description '].fillna('').apply(
        lambda x: x.translate(str.maketrans('', '', string.punctuation)) if isinstance(x, str) else x)
    df['floor_out_of'] = df['floor_out_of'].replace({'קומת קרקע': '0 out_of', 'קומת מרתף': '-1 out_of'})
    df['floor'] = df['floor_out_of'].str.extract(r'(\d+)')
    df['total_floors'] = df['floor_out_of'].str.extract(r'מתוך (\d+)')

    current_date = datetime.datetime.now()

    def calculate_month_difference(date_str):
        try:
            if isinstance(date_str, datetime.datetime):
                date_str = date_str.strftime('%Y-%m-%d %H:%M')
            date = datetime.datetime.strptime(date_str, '%Y-%m-%d %H:%M')
            month_difference = abs((current_date.year - date.year) * 12 + (current_date.month - date.month))
            if month_difference < 6:
                return 'less_than_6 months'
            elif 6 <= month_difference <= 12:
                return 'months_6_12'
            else:
                return 'above_year'
        except ValueError:
            if date_str == 'גמיש':
                return 'flexible'
            if date_str == 'גמיש ':
                return 'flexible'
            elif date_str == 'לא צויין':
                return 'not_defined'
            elif date_str == 'מיידי':
                return 'less_than_6 months'
            else:
                return date_str

    df['entranceDate '] = df['entranceDate '].apply(lambda x: calculate_month_difference(x))

    cols = ['hasElevator ', 'hasParking ', 'hasBars ', 'hasStorage ', 'hasAirCondition ', 'hasBalcony ', 'hasMamad ',
            'handicapFriendly ']
    df[cols] = df[cols].replace({'True': 1, 'False': 0})
    df[cols] = df[cols].apply(
        lambda x: x.dropna().map(lambda value: 1 if str(value).startswith(('כן', 'יש', 'yes', 'נגיש')) else
        (0 if str(value).startswith(('אין', 'לא', 'no')) else
         value)).astype(int) if x.dtype == 'object' else x)
    df.reset_index(drop=True, inplace=True)
    df.columns = df.columns.str.lstrip()
    df.columns = df.columns.str.rstrip()
    condition_replacements = {
        'חדש': 'new',
        'חדש מקבלן': 'new',
        'שמור': 'good_condition',
        'משופץ': 'renovated',
        'דורש שיפוץ': 'needs_renovation',
        'לא צויין': 'not_defined',
        'ישן': 'old',
        "None": 'not_defined',
        False: 'not_defined'}
    df['condition'] = df['condition'].apply(lambda x: condition_replacements.get(x, 'not_defined'))

    furniture_replacements = {
        'אין': 'None',
        'מלא': 'Full',
        'לא צויין': 'not_defined',
        'חלקי': 'partial'}
    df['furniture'] = df['furniture'].apply(lambda x: furniture_replacements.get(x, 'None'))

    replacement_values = {
        'בניין': "Apartment",
        'דירה': "Apartment",
        'דירת גן': "Garden_Apartment",
        'דירת גג': "penthouse",
        'פנטהאוז': "penthouse",
        'מיני פנטהאוז': "penthouse",
        "קוטג'": "private",
        'בית פרטי': "private",
        "קוטג' טורי": "private",
        'דו משפחתי': "private",
        'מגרש': "area",
        'נחלה': "area",
        'דופלקס': "duplex",
        'טריפלקס': "duplex",
        'דירת נופש': np.NaN, }

    df['type'] = df['type'].apply(lambda x: replacement_values.get(x, np.NaN))

    df['floor'] = df['floor'].astype(float)
    df['total_floors'] = df['total_floors'].astype(float)

    df.loc[df['type'] == 'penthouse', 'total_floors'] = df['floor']

    df['room_number'] = df['room_number'].apply(lambda x: re.findall(r'\d+\.?\d*', str(x)))
    df['room_number'] = df['room_number'].apply(lambda x: float(''.join(x)) if len(x) > 0 else np.nan)
    df.dropna(subset=['room_number'], inplace=True)
    df = df[df['price'] <= 15000000]

    # We obtained socioeconomic data from the Bureau of Statistics website,""
    # which includes indexes representing the socioeconomic situation in all neighborhoods across cities in Israel.
    # Our objective was to remove the "City" column without resorting to "One hot encoding" or "get dummies" techniques.
    # By incorporating additional data, we substituted the "City" column with the "Index_value" column.

    excel_file = 'https://github.com/NoaNesher/Advanced-data-mining-in-Python---FinalProject/raw/main/Socioeconomic.xlsx'
    data1 = pd.read_excel(excel_file, engine='openpyxl')
    new_df_City = pd.merge(df, data1, on=['City'], how='left')
    new_df_City = new_df_City.drop_duplicates()
    Nan_data = new_df_City[new_df_City['Index_value'].isnull()]
    new_df_City = new_df_City.dropna(subset=['Index_value'])
    Nan_data = Nan_data.drop(['Index_value'], axis=1)
    new_df = pd.DataFrame()
    new_df['City'] = Nan_data['City']
    new_df = new_df.drop_duplicates()

    def find_closest_match(value, choices):
        ratios = process.extract(value, choices, scorer=fuzz.partial_ratio)
        best_match = max(ratios, key=lambda x: x[1])
        return best_match[0]

    data1['Closest_Match'] = data1['City'].apply(lambda x: find_closest_match(x, new_df['City']))

    def check_similarity(str1, str2):
        return fuzz.partial_ratio(str1, str2)

    filtered_data = data1[data1.apply(lambda row: check_similarity(row['City'], row['Closest_Match']), axis=1) >= 80]
    filtered_data = filtered_data.drop(['City'], axis=1)
    data1 = data1.drop(['Closest_Match'], axis=1)
    filtered_data = filtered_data.rename(columns={'Closest_Match': 'City'})

    avg = pd.concat([filtered_data, data1], ignore_index=True)
    new_df = pd.merge(df, avg, on=['City'], how='left')

    cols_to_drop = ['Street', 'number_in_street', 'num_of_images',
                    'floor_out_of', 'entranceDate',
                    'description', 'city_area']

    new_df.drop(cols_to_drop, axis=1, inplace=True)
    new_df.dropna(subset=['hasElevator', 'hasMamad', 'hasBars', 'room_number', 'type'], inplace=True)

    return new_df




